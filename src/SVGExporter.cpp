#include "SVGExporter.hpp"

void SVGExporter::addBuilding(const Building& building){
	buildings.push_back(building);
};

void SVGExporter::addPath(const Path& path){
	paths.push_back(path);	
};

void SVGExporter::exportSVG(const std::string& filePath){
	std::ofstream svgFile(filePath.c_str());
	if(svgFile.is_open()){

		//Calculate SVG frame size.
		float width = -1;
		float height = -1;
		for(size_t i = 0; i < paths.size(); ++i){
			for(size_t j = 0; j < paths[i].getPathPoints().size(); ++j){
				const std::vector<float>& pathPoints = paths[i].getPathPoints();
				if(j % 2 == 0 && pathPoints[j] > width)
					width = pathPoints[j];
				else if(j % 2 == 1 && pathPoints[j] > height)
					height = pathPoints[j];
			}
		}
		for(size_t i = 0; i < buildings.size(); ++i){
			for(size_t j = 0; j < buildings[i].getPlotPoints().size(); ++j){
				const std::vector<float>& plotPoints = buildings[i].getPlotPoints();
				if(j % 2 == 0 && plotPoints[j] > width)
					width = plotPoints[j];
				else if(j % 2 == 1 && plotPoints[j] > height)
					height = plotPoints[j];
			}
		}

		//SVG header
		svgFile << "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
		svgFile << "<!-- Autogenerated SVG File -->\n<!-- Map Synthesiser by Liam de Valmency, 2013 -->\n";
		svgFile << "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"";
		svgFile << width << "\" height=\"" << height << "\">\n";

		//Building polygons
		svgFile << "<g id=\"map\">\n<g id=\"Polygons\" style=\"stroke-linejoin:round\">\n";
		svgFile << "<g id=\"buildings\" style=\"fill:#BCA9A9\">\n";

		for(size_t i = 0; i < buildings.size(); ++i){
			if(!buildings[i].exportStatus())
				continue; 

			const std::vector<float>& plotPoints = buildings[i].getPlotPoints();

			svgFile << "<path d=\"M" << plotPoints[0] << " " << plotPoints[1] << " l";

			float prevX = plotPoints[0];
			float prevY = plotPoints[1];

			for(size_t j = 2; j < plotPoints.size() - 1; j += 2){
				float xDiff = plotPoints[j] - prevX;
				float yDiff = plotPoints[j + 1] - prevY;
				svgFile << xDiff << " ";
				svgFile << yDiff << " ";
				prevX += xDiff;
				prevY += yDiff;
			}

			svgFile << "Z\" />\n";
		}

		//Path lines
		svgFile << "</g>\n</g>\n";

		svgFile << "<g id=\"roads\" style=\"stroke-linecap:round;stroke-linejoin:miter;fill:none\">\n";

		//TODO: Group output paths by width.
		for(size_t i = 0; i < paths.size(); ++i){
			if(!paths[i].exportStatus())
				continue;

			const std::vector<float>& pathPoints = paths[i].getPathPoints();

			svgFile << "<g id=\"road_" << i << "\" style=\"stroke:#A6A6A6;stroke-width:" << paths[i].getSize();
			svgFile << "\">\n<path d=\"M" << pathPoints[0] << " " << pathPoints[1] << " l";

			float prevX = pathPoints[0];
			float prevY = pathPoints[1];

			for(size_t j = 2; j < pathPoints.size() - 1; j += 2){
				float xDiff = pathPoints[j] - prevX;
				float yDiff = pathPoints[j + 1] - prevY;
				svgFile << xDiff << " ";
				svgFile << yDiff << " ";
				prevX += xDiff;
				prevY += yDiff;
			}

			svgFile << "\" />\n</g>\n";
		}

		if(exportGrid){
			std::stringstream ss;
			ss << grid.lineSize;
			svgFile << "</g><g id=\"grid\" style=\"stroke:#000000;stroke-width:" << ss.str() << "\">\n";;
			for(int i = 0; i < grid.yTiles; ++i){
				svgFile << "<path d=\"M0 " << (i * grid.tileHeight);
				svgFile << " h" << (grid.xTiles * grid.tileWidth) << "\" />\n";
			}
			for(int i = 0; i < grid.xTiles; ++i){
				svgFile << "<path d=\"M" << (i * grid.tileWidth) << " 0 v";
				svgFile << (grid.yTiles * grid.tileHeight) << "\" />\n";
			}
			svgFile << "</g>\n";
		}


		//EOF
		svgFile << "</g></svg>\n";
	}

	svgFile.close();
};
